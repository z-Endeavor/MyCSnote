# JavaScript



## 变量

#### var - 全局变量：全局作用域。

- **存在变量提升**，可以**在声明之前调用**，值为undefined
- 一个变量**可以多次声明**，后面的声明会**覆盖前面的声明**
- 在**函数中**使用var声明变量的时候，该变量**是局部的**。但<u>函数中不使用var声明，该变量是全局的。</u>

#### let - 局部变量：可以重新赋值。

- **不存在变量提升**，let声明变量前，该变量不能使用（暂时性死区）
- let**所在的代码块内有效**，在**块级作用域**内有效
- let**不允许在相同作用域中重复声明**，不同作用域有重复声明不会报错。

#### const - 常量：不能重新赋值。

- 声明一个**只读**的变量，声明后值不能改变
- **必须初始化**
- **不是变量的值不能改动**，而是变量指向的内存地址所保存的数据不能改动
- <u>let 的所有特点</u>

#### 区别

1. **变量提升**。var存在变量提升，而let、const必须在声明后使用。
2. **块级作用域**。var不存在块级作用域，let、const存在块级作用域。
3. **重复声明**。var可以重复声明变量，let、const在同一作用域不允许重复声明。
4. **修改声明变量**。var、let可以，const只读。**但对于数组和对象这种引用类型，其中的值是可以改变的，但不能重新赋值，内存地址不能修改。**

#### 使用

能用const就用const，大多数使用let，避免使用var。（const > let > var ）

let一般应用于**基本数据类型**；const 一般应用于**引用数据类型**，也就是函数对象等。

const声明的好处，一让阅读代码的人知道该变量不可修改，二是防止在修改代码的过程中无意中修改了该变量导致报错，减少bug的产生。

let声明没有产生预编译和变量提升的问题，先声明再使用可以让代码本身更加规范，let是个块级作用域，也不会污染到全局的变量声明。

> ​	在ES6中，用**let、const**、import、class定义的全局变量并**没有作为全局对象的属性**，所以通过window获取时，如果window存在和变量同名的属性，则获取的是window中该属性的原始值，否则为undefined。



## 数据类型

JS分为 **基本数据类型** 和 **引用数据类型** 。

### 基本类型

基本数据类型有 **字符串（String）、数字（Number）、布尔（Boolean）、空（Boolean）、未定义（Undefined）、Symbol** 。

- `String`：以 `''` 或 `""` 包裹起来的文本。若包含引号， 可以使用 `\` 反斜杠转义字符串中的引号。
- `Number`：不区分整数和小数（浮点数）。

> NaN 是特殊值，表示不是数字，但是属于 Number 类型，不等于任何值。

- `Boolean`：只有 true 和 false 两个值。
- `Null`：只有一个值，表示不存在任何值，用来定义空对象指针。

> 使用 `typeof` 查看 Null类型，结果为 Object ，说明 Null 其实属于 Object（对象） 的一个特殊值。

- `Undefined`：只有一个值，表示未定义。当声明变量后未赋值，默认值就是Undefined。
- `Symbol`：ES6引入的新的数据类型，表示独一无二的值，需要用Symbol()函数来生成。

```javascript
var str = "123";
var sym1 = Symbol(str);
var sym2 = Symbol(str);
console.log(sym1);          // 输出 Symbol(123)
console.log(sym2);          // 输出 Symbol(123)
console.log(sym1 == sym2);  // 输出 false ：虽然 sym1 与 sym2 看起来是相同的，但实际上它们并不一样，根据 Symbol 类型的特点，sym1 和 sym2 都是独一无二的
```

基本数据类型是**按值访问**的，也就是说**可以操作保存在变量中实际的值**。

### 引用类型

引用数据类型有 **对象（Object）、数组（Array）、函数（Function）等**。

- `Object`：是一组由键、值组成的无序集合，定义使用 `{}` 。
- `Array`：是一组按顺序排列的数据集合，可以包含任意类型的数据，定义使用 `[]` 或者 `new Array()`，每个元素用逗号分隔。
- `Function`：是一段特定功能的代码块。

#### 区别

1. **值的可变性：**
   - 基本类型的值是**不可变**的，原始值无法通过方法改变，也不能添加属性和方法。
   - 引用类型的值是可变的，可以添加删除属性和方法，可以**动态改变**。
2. **值比较：**
   - 基本类型只有**值相等**的时候才相等。
   - 引用类型的比较是**引用的比较**。
3. **内存存放：**
   - 基本类型的存放在**栈区**，包括<u>变量的标识符和变量的值</u>。
   - 引用类型同时保存在**栈内存和堆内存**中，栈区存放<u>变量标识符</u>和<u>该对象在堆内存的地址</u>。



## == 和 === 的区别

== 比较时，**不同类型的数据会转换成一致后再做比较**。

=== 比较时，如果类型不一致就直接返回 `false` ，**类型相同才会比较**。



## 深浅拷贝

深浅拷贝是只针对Object和Array这样的引用数据类型的。

> 引用数据类型**存储的是该对象在栈中的引用，真实的数据存放在堆内存里**。在栈中的指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

- **浅拷贝**：只复制**指向某个对象的指针**，而不复制对象本身，**新旧对象还是共享同一块内存**。
- **深拷贝**：会另外**创造一个一模一样的对象**，新对象跟原对象**不共享内存**，**修改新对象不会改到原对象**。

[js浅拷贝与深拷贝的区别和实现方式 - 简书 (jianshu.com)](https://www.jianshu.com/p/1c142ec2ca45)



## Set

Set 与数组类似， Set 集合中的**元素不重复**。

- 查找元素`set.has()`： 在数组中使用 indexOf() 或 includes() 检查元素是否存在比较慢。
- 删除元素`set.delete()`： 在 Set 中，可以通过值删除元素。即在数组中，基于索引的splice() 功能。
- 插入元素`set.add()`： 在 Set 中添加元素比在数组中通过 push()、 unshift() 或其他同类操作要快。
- 去重： Set 对象仅能存储不同的值。



## 原型

**原型:** 对象中固有的 `__proto__` 属性，该属性指向对象的 `prototype` 原型属性。

- 每一个`构造函数`都有一个`原型属性prototype`指向他的`原型对象`；
- 每一个`原型对象`中都有一个`constructor属性`指向他的`构造函数`；
- 每一个`实例`（除了null）都有一个属性叫`__proto__`指向`原型对象`；
- 写在`构造函数内的属性和方法只有构造函数本身可以调用`，原型对象与实例都不可以调用；
- 写在原型对象的属性和方法称为实例属性和实例方法，既可以`通过实例调用`，也可以`通过原型对象调用`；
- `构造函数`可以创建`多个实例`，每个实例都有自己的属性和方法，实例也可以`继承原型对象中的属性和方法`；
- 所有实例对象都会从它的原型上继承一个 `constructor` ，指向原型对象

**原型链:** 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是`Object.prototype`所以这就是我们新建的对象为什么能够使用`toString()`等方法的原因。

**特点:** `JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。



## 闭包

有权访问另一个函数作用域中的变量的函数；一般情况就是在<u>一个函数中包含另一个函数</u>。

- 闭包是一个**函数**，而且存在于另一个函数当中
- 闭包**可以访问到父级函数的变量**，且该变量**不会销毁**

#### 原理

利用了**作用域链**的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果<u>不存在就一直向外层寻找</u>，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。

因此使用闭包时，按照作用域链的特点，<u>闭包（函数）外面的变量不会被销毁</u>，因为函数会一直被调用，所以一直存在。（内存泄漏）

#### 作用

1. 隐藏变量，避免全局污染
2. 可以读取函数内部的变量

```javascript
function person(){
    var age = 18;
    function cat(){
        age++;
        console.log(age);
    }
    return cat;
}
// person();// 19
// person();// 19

var per = person();//per相当于函数cat
per();// 19 即cat() 这样每次调用不在经过age的初始值，这样就可以一直增加了
per();// 20
per();// 21
```

**缺点**

1. 导致变量不会被垃圾回收机制回收，造成**内存消耗**
2. 不恰当的使用闭包可能会造成**内存泄漏**的问题



## Promise

**`Promise`** 对象用于表示一个**异步操作**的最终完成（或失败）及其结果值。可以理解为一个容器，保存着将来才会结束的事件（异步操作）的结果。

Promise 对

一个 `Promise` 必然处于以下几种状态之一：

- *待定（pending）*：初始状态，代表进行中，既没有被兑现，也没有被拒绝。
- *已兑现（fulfilled）*：意味着操作成功完成。
- *已拒绝（rejected）*：意味着操作失败。

### 链式调用

`Promise.prototype.then()`、`Promise.prototype.catch()` 和 `Promise.prototype.finally()` 这些方法返回的是promise，可以将进一步的操作与一个变为已敲定状态的 promise 关联起来链式调用。

```javascript
const p = new Promise((res, rej) => {
  res(117);
  setTimeout(() =>{
    throw new Error('None');
  }, 0);
});
p.then((res) =>{
  console.log(res);
}).catch((err) =>{
  console.log(err)
})

// 117 报错
```

### 优势

普通异步处理包括 ajax异步请求、事件监听。

1. 和 `Ajax` 对比：Promise 把 ajax 返回成功 / 失败的回调封装成一个 Promise 对象（同时判断 resolve / reject 状态），用链式调用**避免ajax回调地狱**（反复嵌套回调），代码不够直观，**不易读** 也 **不易维护**。
2. 和事件监听对比：**一旦Promise状态改变就不会再变**，如果状态已经改变，再对Promise对象添加回调函数，也会立即得到这个结果，**这和事件不同**，事件的特点是：如果错过了事件，再去监听是得不到结果的。更方便保存状态。

> Ajax回调地狱：函数作为参数，进行层层的嵌套，被称之为回调地狱。因为层层的回调，所以很难直接的观察到正确的执行结果。



## 宏任务和微任务

宏任务（macroTask）和微任务（microTask），都是JavaScript中异步中的一些概念。

- 宏任务：setTimeout，setInterval，Ajax，DOM事件
- 微任务：Promise，async/await

**微任务的执行时机要比宏任务早**。

> Dom事件不是异步操作，但是它依赖了eventloop机制。



## 函数参数

`...arg` 可以代表函数中**可变参数**。

```javascript
function func(arg, ...obj) {
  console.log(arguments.length, obj.length, func.length);
};

func(1,2,3);

// 3 2 1
```

- `argument.length` 代表**实际参数数量**。
- `obj.length` 代表**可变参数列表长度**。
- `func.length` 代表**函数必须要传入的参数个数**。



## 事件流

事件流描述的是从页面中接收事件的顺序，即事件在目标元素和祖先元素间的触发顺序。DOM2级事件流包括下面几个阶段：

1. 事件捕获阶段：事件**从最顶层向下传播**，从window一直传递到目标元素。
2. 处于目标阶段：到达目标元素。<u>若指定不冒泡，则中止</u>。
3. 事件冒泡阶段：事件**从下往上传播**，事件由第一个被触发的元素接收，逐级向上传递直到最顶层元素。

`addEventListener` ：是DOM2级事件的指定事件处理程序的操作，要处理3个参数（事件名、事件处理函数、布尔值）。若布尔值参数为 `true` ，则在捕获阶段调用事件处理程序；如果为 `false` ，则在冒泡阶段调用事件处理程序。

> 默认设置为**事件冒泡阶段**。IE 只支持事件冒泡。

### 事件委托

利用DOM的**冒泡事件流**，注册最少的监听器，<u>实现对DOM节点的所有子元素进行事件群控</u>。

一般来说会把**一个或者一组元素的事件委托到它的父层或者更外层元素**上，当事件响应到需要绑定的元素上，会**通过事件冒泡机制触发外层元素的绑定事件**，然后在外层事件上执行函数。

利用 事件委托 可以减少与DOM节点进行交互以及浏览器重绘和重排的次数，提高性能。

### target 和 currentTarget

- `target` ：触发事件的元素
- `currentTarget` ：事件绑定的元素

事件不支持冒泡的时候，两者指的是同一个元素。

事件支持冒泡的时候，比如父元素和子元素都绑定click事件，当点击子元素时，父元素的事件也会触发，此时父元素事件的currentTarget指向父元素，target指向子元素。



## 跨域

现代浏览器出于安全考虑，都会去遵守一个叫做“同源策略”（**同源策略**就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互）的约定，同源的意思是两个地址的**协议、域名、端口号**都相同的情况下，才叫同源。如果三者有一个不同，就是不同源，这时再去访问这些资源就叫做**跨域**。

1. 端口和协议的不同，只能通过后台来解决
2. localhost和127.0.0.1虽然都指向本机，但也属于跨域。

但**请求不会携带cookie**时，就没有跨域限制：

1. js、css、image等静态文件
2. form表单提交

同源策略限制：

1. Cookie、LocalStorage 和 IndexDB 无法读取
2. DOM 和 JS 对象无法获取
3. Ajax请求发送不出去（XHR对象）

#### 解决跨域问题

原理即是通过各种方式，避开浏览器的安全限制。

1. **JSONP方法;**

   通过**动态创建script**，请求一个带参网址实现跨域通信，可以访问到其他服务器上的js、css、image静态资源。但<u>只能实现**get**一种请求</u>。

2. **document.domain + iframe跨域**

   如果<u>主域相同，子域不同</u>的跨域应用场景下，可以通过两个页面都通过js强制设置`document.domain`为**基础主域**，就实现了同域。

3. **location.hash + iframe跨域**

   通过**中间页**来实现跨域，不同域之间通过iframe的`location.hash`传值，相同域之间直接js访问来通信。`A域:a.html => B域:b.html => A域:c.html`

4. **window.name + iframe 跨域**

   name值在不同页面（域名）加载后依旧存在，并且可以支持非常长的name值。

   通过iframe的src属性由外域转向本地域，跨域数据即由**iframe和window.name从外域传到本地域**，绕过了浏览器的跨域访问限制。需要有一个<u>与本地域同域的中间代理页</u>。

5. **window.postMessage方法；**

   `postMessage(data,origin)`方法接受两个参数：data - html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin - 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口。

6. **跨域资源共享（CORS）**

   服务端设置`Access-Control-Allow-Origin` ，前端无须设置，若要带cookie请求，前后端都要设置。

7. **nginx反向代理跨域**

   通过niginx配置一个代理服务器做跳板机，反向代理访问domain2接口，顺便修改cookie中domain信息，方便当前域cookie写入。

8. **nodejs中间件跨域**

   原理和nginx相同，启一个代理服务器，实现数据转发。



## 添加JavaScript方式

1. 使用**script标签**，将javascript代码写到 `<script></script>` 之间。
2. 添加**外部javascript文件**。一般将 `<script>` 定义在 head 或 body 中。
3. 使用**行内javascript**。必须结合事件来使用。

**注意**：使用@import引入css文件，但是不能引入js文件。



## 正则表达式

正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，**正则表达式也是对象**。

这些模式被用于 `RegExp` 的 `exec` 和 `test` 方法，以及 `String` 的 `match`、`matchAll`、`replace`、`search` 和 `split` 方法。

### 字符

| 表达式 | 描述                                             |
| ------ | ------------------------------------------------ |
| [abc]  | 字符集。匹配集合中任一字符。                     |
| [^abc] | 否定字符集。匹配任何不在集合中的字符。           |
| [a-z]  | 字符范围。匹配指定范围内的任意字符。             |
| .      | 匹配除换行符以外的任何单个字符                   |
| \      | 转义字符                                         |
| \w     | 匹配任意字母数字，包括下划线（`[A-Za-z0-9_]`)    |
| \W     | 匹配任意非字母数字，包括下划线（`[^A-Za-z0-9_]`) |
| \d     | 数字。匹配任何数字。                             |
| \D     | 非数字。匹配任何非数字字符。                     |
| \s     | 空白。匹配任何空白字符，包括空格、制表符等。     |
| \S     | 非空白。匹配任何非空白字符。                     |

### 锚点/边界

| 表达式 | 描述                                       |
| ------ | ------------------------------------------ |
| ^      | 匹配字符串或行开头。                       |
| $      | 匹配字符串或行结尾。                       |
| \b     | 匹配单词边界。`now\b => rightnow`          |
| \B     | 匹配非单词边界。 `right\B => justrightnow` |

### 数量表示

| 表达式 | 描述                               |
| ------ | ---------------------------------- |
| ？     | 匹配前面的表达式0或1个。即可选项。 |
| +      | 匹配前面的表达式至少1个。          |
| *      | 匹配前面的表达式0个或多个。        |
| \|     | 或运算符。                         |
| {m}    | 匹配前面的表达式m个。              |
| {m,}   | 匹配前面的表达式最少m个。          |
| {m,n}  | 匹配前面的表达式m-n个。            |

### 特殊标志

| 表达式 | 描述                       |
| ------ | -------------------------- |
| /.../i | 忽略大小写                 |
| /.../g | 全局匹配                   |
| /.../m | 多行修饰符，用于多行匹配。 |



## 全局函数

- decodeURI(string)：对encodeURI()编码过的URI进行解码
- decodeURIComponent(string)：对encodeURIComponent()编码过的URI进行解码
- encodeURI(string)：字符串某些字符将被十六进制的转义序列进行替换
- encodeURIComponent(string)：可把字符串作为URI组件进行编码
- escape(string)：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串
- unescape(string)：可以使用 unescape() 对 escape() 编码的字符串进行解码
- eval(string)：eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。
- getClass(javaobj)：返回一个 JavaObject 的 JavaClass。
- **isFinite(number)**：检查其参数**是否是无穷大**
- **isNaN()**：用于检查其参数**是否是非数字值**
- **Number(object)**：把对象的值**转换为数字**
- **parseInt(string)**：**解析一个字符串，并返回一个整数**
- **parseFloat(string)**：**可解析一个字符串，并返回一个浮点数**。
- **String(object)**：把对象的值**转换为字符串**





# HTML



## 行内样式

`style` 属性规定元素的行内样式（inline style）

style 属性将**覆盖任何全局的样式设定**，例如在 `<style> ` 标签或在外部样式表中规定的样式。



## HTML元素

包括 **块级元素** 和 **行内元素** 。可以通过display属性互相转换。

#### 块级元素

在浏览器中**占据整行**，并排斥其它元素与其位于同一行。也就是说，块级元素的宽度是 100%。

- 总是从新的一行开始，即各个块级元素**独占一行，默认垂直向下排列**；
- **高度、宽度、margin及padding都是可控的，设置有效**，有边距效果；
- 宽度没有设置时，默认为100%；
- 块级元素中**可以包含块级元素和行内元素**。

常见的包括：`<div>、<table>、<form>、<p>、<ul>、  <h1>......<h6>、<hr>  、<pre>、<address>、<center>、<marquee> 、<blockquote>  `等。

#### 行内元素

又称内联元素（inline block）。在浏览器中可以**与其它行内元素共占一行**，只有当多个元素的总宽度大于浏览器的宽度时，才会换行显示。

- 和其他元素都在一行，即行内元素和其他行内元素都会**在一条水平线上排列**；
- **高度、宽度是不可控的，设置无效**，由<u>内容决定</u>。
- 根据标签语义化的理念，行内元素**最好只包含行内元素，不包含块级元素**。

常见的包括：`<span>、<a>、 <img>、 <input>、<textarea>、<select>、<label>`



## 链接

- html5标准的链接**默认都是带下划线**的
- bootstrap链接只有**在hover状态下才带下划线**



## W3C标准

1. 标签规范可以**提高搜索引擎对页面的抓取效率**，对SEO（搜索引擎优化）很有帮助。
2. **尽量使用外链css样式表和js脚本**。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。
3. 样式**尽量少用行间样式表，使结构与表现分离**，标签的id和class等属性命名要做到**见文知义**，**标签越少，加载越快**，用户体验提高，代码维护简单，便于改版

> jQuery不符合W3C标准。



## HTML语义化

页面**去掉样式**或者**加载失败**的时候能够**让页面呈现出清晰的结构**。

HTML5新增了好多语义化的标签，例如：header、footer、nav、menu、section、article、aside等等，**单单从字面上理解，就知道标签的含义**。

> div、span、br、hr、pre这些属于无语义化元素。

#### 好处

1. 在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构
2. 用户体验：例如title、alt用于解释名词
3. 有利于SEO：利于被搜索引擎收录，更便于搜索引擎的爬虫程序来识别
4. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页
5. 便于项目的开发及维护，使HTML代码更具有可读性



## canvas

**Internet Explorer 9+, Firefox, Opera, Chrome, 和 Safari** 支持  `<canvas>`  标记。





# CSS



## 盒子模型

盒子模型本质上就是一个盒子，封装周围的HTML元素，它包括四个部分：

-  `content` ：实际内容
- `padding` ：内边距，清除内容周围的区域，是透明的，**取值不能为负**，受盒子 `background`属性影响。
- `border` ：边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成。
-  `margin` ：外边距，在元素外创建额外的空白，通常指不能放其他元素的区域。

> `width / height `属性只是内容宽度和高度，不包含其他的。
>
> 盒子总宽度 = width + padding + border + margin
>
> 盒子总高度 = height + padding + border + margin



## 样式表类型

1. **行内样式表（内联式样式）**

   利用**style属性**将样式写在HTML标签中。

2. **内部样式表**

   将样式代码写在页面 `<style>...</style>` 标签之中

3. **链接样式表（.css文件）**

   css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在 `<head>` 内使用`<link>` 标签将css样式文件**链接**到HTML文件内

4. **导入样式表（@import）**

   @import**一定要写在其他的CSS规则之前**，如果置于其他位置会被浏览器忽略

优先级采用 **就近原则** ，越靠近相关标签的样式优先级更高。

- **行内样式优先级最高**。
- **内部样式优先级大于导入样式**。
- 链接样式和内部样式、导入样式的优先级与**文档顺序**相关。



## 样式和选择器

一般来说，**样式的优先级**为：

（外部样式）`External style sheet` <（内部样式）`Internal style sheet` <（内联样式）`Inline style`

但如果外部样式表引入位置在内部样式后，则外部样式会覆盖内部样式表。

也就是说，**距离HTML元素近的会覆盖距离远**的。

**选择器的优先级**是通过<u>计算规则</u>算的，一般来说：

`!important > 内联样式 > id选择器 > 类选择器（属性选择器） > 标签选择器 > 通配符选择器(*)`



## 相邻选择器

也叫兄弟选择器。

1. `+`： 类名1 + 类名2 ，则只能选中类名2。
2. `~`： 类名1 ~ div，则选中除类名1的所有兄弟类。类名1 ~ 类名3，则选中类名3（间隔的兄弟）。



## BFC 块格式化上下文

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

### 创建BFC

1. 浮动元素：float属性不为`none`（指定float为left或者right都可以）
2. 绝对定位元素：position为`absolute`或`fixed`
3. display: `inline-block`、`table-cell`、`table-caption`、`flex`、`inline-flex`
4. overflow不为`visible`

### BFC特点

1. 在BFC中，盒子从顶部开始垂直地一个接一个排列
2. 盒子垂直方向的距离由margin决定。同一个BFC的两个相邻盒子margin会重叠。
3. BFC中，margin-left会触碰到border-left（对于从左至右的方式，反之）
4. BFC区域不会与浮动的盒子产生交集，而是紧贴边缘浮动
5. 计算BFC高度时，自然会检测浮动的盒子高度

### BFC用途

1. 清除内部浮动，父元素设置为BFC可以清除子元素的浮动（最常用overflow:hidden，IE6需加上*zoom:1）：计算BFC高度时会检测浮动子盒子高度
2. 解决外边距合并问题
3. 右侧盒子自适应：BFC区域不会与浮动盒子产生交集，而是紧贴浮动边缘



## 定位

1. **静态定位static**

   是 position 属性的**默认值**，表示没有定位，使用静态定位的元素会按照元素正常的位置显示，并且不会受到 top、bottom、left、right 和 z-index 属性的影响。

2. **相对定位relative**

   是元素**相对于自己默认的位置来进行位置上的调整**，您<u>可以通过 top、bottom、left 和 right 四个属性</u>的组合来设置元素相对于默认位置在不同方向上的偏移量。

   > 相对定位的元素可以移动并与其他元素重叠，但会**保留元素默认位置处的空间**。

3. **绝对定位absolute**

   相对于第一个**非静态定位（static）的父级元素进行定位**，如果找不到符合条件的父级元素则会相对与浏览器窗口来进行定位。您同样可以<u>使用 top、bottom、left 和 right 四个属性</u>来设置元素**相对于父元素或浏览器窗口**不同方向上的偏移量。

   > 使用绝对定位的元素会脱离原来的位置，不再占用网页上的空间。

4. **固定定位fixed**

   将元素**相对于浏览器窗口**进行定位，使用固定定位的元素**不会因为浏览器窗口的滚动而移动**，就像是固定在了页面上一样，我们经常在网页上看到的<u>返回顶部按钮就是使用固定定位</u>实现的。

   > fixed属性的元素在标准流中**不占位置**。

5. **粘性定位sticky**

   像是相对定位和固定定位的结合体，当滚动页面时它的效果与相对定位相同，当元素滚动到一定程度时它又会呈现出固定定位的效果。比如一些网页上的导航菜单，当页面加载完成时它在自己默认的位置，当我们向下滚动页面时它又会固定在页面的最顶端。

   > 在设置`position:sticky;`时，必须再定义 top、bottom、right、left 四个属性之一，否则只会处于相对定位；



## 伪类

- :hover选择器：当鼠标**悬停在所指定的元素**上时所使用的样式；
- :active选择器：当所指定的元素处于**激活状态**（鼠标在元素上按下还没有松开）时所使用的样式；
- :focus选择器：当元素获得光标焦点时使用的样式，主要用在**文本框输入文字**时使用；



## 实现水平垂直居中

### 文本居中

```css
.test {
	text-align: center; /* 水平居中 */
	line-height: 200px;	/* 垂直居中 */
}
```

### 元素居中

1. **弹性布局 `flex`**

   给**父元素**添加弹性布局 `flex`，通过设置 `align-items` （垂直居中） 和  `justify-content`（水平居中）为 `center` 属性，来**定义子元素水平垂直居中**。

2. **绝对定位 + margin（auto）**

   ```css
   .test{
   	position: absolute;
   	top: 0;
   	bottom: 0;
   	left: 0;
   	right: 0;
   	margin: auto;
   }
   ```

3. **绝对定位 + margin**

   设置 `margin-top` 、`margin-left` 偏移量。（<u>需要提前知道元素宽高</u>）

   ```css
   .test{
   	height: 200px;
   	width: 150px;
   	position: absolute;
   	top: 50%;
   	left: 50%;
   	margin-top: -100px;
   	margin-left: -75px;
   }
   ```

4. **绝对定位 + transform**

   使用平移，`transform` 实现 `margin-top` 、`margin-left`。

```css
.test {
	position: absolute;
	left:50%;
  	top:50%;
	transform: translate(-50%, -50%);
}
```



## 行内元素设置宽高

1. display：转换为块级元素或者块级行内元素。

   `display: block / inline-block;`

2. float：给行内元素添加浮动。

   `float：left / right;`

3. position：给行内元素添加绝对定位或固定定位。

   `position: absolute / fixed;`



## 单位

- px：绝对单位，代表屏幕中每个「点」( pixel )。
- em：相对单位，每个子元素通过「倍数」乘以**父元素**的px值。
- rem：相对单位，每个元素通过「倍数」乘以**根元素**的px值。
- %：相对单位，每个子元素通过「百分比」乘以父元素的px值。

字体大小单位可以是em，1em = 16px。





# 浏览器



## 提高cookie安全性的方法

1. 对保存到cookie里面的敏感信息必须加密
2. 设置HttpOnly为true，**无法通过脚本访问或操作**，防止关键性的数据被恶意获取。
3. 设置Secure为true，强制开启HTTPS连接。
4. 给Cookie设置有效期
5. 给Cookies加个时间戳和IP戳，实际就是让Cookies在同个IP下多少时间内失效。



## 浏览器本地存储技术

### cookie和session

cookie和session都可用来存储用户信息。

1. cookie 数据存放在客户端的浏览器上，session 数据放在服务器上。
2. cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行cookie欺骗。考虑到安全应当使用 session。
3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie。
4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。

### cookie、localStorage和sessionStorage 

都是保存在浏览器端，并且是同源的。

#### 生命周期

- cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效
- localStorage：除非被手动清除，否则将会永久保存。
- sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。

#### 存放数据大小

- cookie：4KB左右
- localStorage和sessionStorage：可以保存5MB的信息。

#### http请求

- cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
- localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

#### 易用性

- cookie：需要程序员自己封装，源生的Cookie接口不友好
- localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持

#### 应用场景

从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。

storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了。

localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。



## 浏览器输入URL发生了什么

1. **URL解析**

   - 用户输入URL，浏览器会根据用户输入的信息判断是**搜索还是网址**，如果是<u>搜索内容+默认搜索引擎合成新的URL</u>；如果用户输入的内容符合URL规则，浏览器就会<u>根据URL协议，在这段内容加上协议合成合法的URL</u>。

2. **DNS查询**

   - 输入URL后，首先需要找到URL域名的服务器IP，因此浏览器**先去查看缓存中是否有记录**（<u>浏览器缓存—系统缓存—路由器缓存</u>）。
   - 若缓存中没有则**查找系统的hosts文件**是否有记录。
   - 若没有则**向本地配置的首选DNS服务器发起域名解析请求**。
   - 最终得到服务器的IP地址。

3. **TCP连接**

   - 在确定目标服务器服务器的IP地址后，则经历**三次握手**建立TCP连接。
   - 发送端首先**发送一个带SYN**（synchronize）标志的数据包给接收方。
   - 接收方收到后，**回传一个带有SYN / ACK** (acknowledegment)标志的数据包以示传达确认信息。
   - 最后发送方再**回传一个带ACK**标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP会再次发送相同的数据包。 TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。

4. **HTTP请求**

   - TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了，**发送HTTP请求报文**到目标服务器。
   - 服务器接受到请求，就解析请求头，如果头部有缓存相关信息如f-none-match与f-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。

5. **接受响应**

   - 服务器解析请求作出响应，返回相应的HTML给浏览器。
   - 因为HTML是一个树形结构，浏览器根据这个HTML来构建DOM树。
   - 在DOM树构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码（JS阻塞)

6. **渲染页面**

   - 渲染进程解析 HTML，构建DOM树。
   - 渲染引擎解析CSS 样式表，转化为浏览器可以理解的styleSheets，生成CCSOM（CSS规则树）。
   - 合成DOM树和CSS规则树，生成render树（渲染树）。
   - 布局render树（Layout / reflow），计算得到元素的布局信息（尺寸、位置——几何信息）。

   > reflow 回流： 重新渲染的过程。

   - 绘制render树（paint / repaint），根据渲染树以及回流得到的几何信息，得到节点的绝对像素，绘制页面像素信息。

   - 浏览器进程将各合成层信息发送给GPU，GPU合成，根据指令生成页面，并显示到显示器上。

[浏览器渲染原理流程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/271859197)



## 回流和重绘

回流（reflow）就是**元素的位置**发生了改变（不管是添加、删除元素，还是元素尺寸改变）。

**触发条件：**

1. JS更改DOM元素（插入，删除、更新、移动、添加动画等，更改DOM颜色除外）
2. 样式表添加或者删除（add/delete stylesheets）
3. 窗口大小改变（screen change）
4. 字体大小改变（font size change）
5. 激活伪类，如:hover（:hover颜色除外）
6. 改变样式属性（颜色，透明度等除外）
7. 更改元素的className
8. 位置计算（对诸如offsetHeight或getComputedStyle之类的元素进行测量）
9. 修改页面上的内容，例如输入框中的文本、用户输入（user input）

重绘（repaint）就是元素位置不会发生改变，而视觉效果会有所改变。

**触发条件**：

1. color的修改，如color=#ddd；
2. text-align的修改，如text-align=center；
3. a:hover也会造成重绘。
4. :hover引起的颜色等不导致页面回流的style变动。




# Vue



## EventBus

相当于一个全局的仓库，任何组件都可以去这个仓库里获取事件，**有组件发布事件后 剩余的所有组件都可以进行监听事件**。

### 使用

1. **创建EventBus**

   创建新的Vue示例 `new Vue()` ，挂载到Vue的原型上 `Vue.prototype.$bus`，保证所有组件都能通过 `this.$bus` 访问到EventBus。

2. **页面使用 发布事件 - 传递值 （`$emit`）**

   `this.$bus.$emit('事件名', 额外参数)`

3. **订阅事件 - 接收组件值 （`$on`）**

   在 create 中订阅，回调函数需要写成箭头函数。 `this.$bus.$on('事件名', 回调函数[对形参进行操作])`

> 1. 父子组件是**嵌套关系**时，需要**`$on` 先执行 在执行 `$emit `触发事件**。<u>把父组件中的$emit事件放在mounted钩子函数中 等待子组件创建并注册$on事件后再去触发$emit</u>。 若兄弟关系就没事。
> 2. 需要**移除事件监听**，防止内存泄漏。**在子组件销毁后进行取消订阅事件**（destoryed生命周期中）。

### 发布订阅模式

**引入中间平台（EventBus）来进行注册和通知，从观察者（组件）中解耦出来。**

观察者通过 `on` 向 `EventBus` 注册事件，然后 `Subject` 通过 `emit` 向 `EventBus` 发射事件，由 `EventBus` 来向观察者更新。





v-on：监听DOM事件







