# 数据结构与算法



## 数组

- 在内存中，数组是一块**连续的区域**。
- 数组需要**预留空间**，使用前需要提前申请所占内存的大小，这样不知道需要多大的空间，就预先申请可能会浪费内存空间，即数组**空间利用率低**。
- 在数组起始位置处，插入数据和删除数据效率低。
- **随机访问效率很高**，时间复杂度可以达到O(1)
- 数组开辟的空间，在不够使用的时候需要扩容，扩容的话，就会涉及到需要把旧数组中的所有元素向新数组中搬移。**大小固定，不能动态拓展**。
- 数组的**空间是从栈分配**的



## 链表

- 在内存中，元素的空间可以在任意地方，**空间是分散的，不需要连续**
- 链表中的元素都会两个属性，一个是**元素的值**，另一个是**指针**，此指针标记了下一个元素的地址
- **查找数据时效率低**,时间复杂度为O(N)
- 空间不需要提前指定大小，是**动态申请**的，根据需求动态的申请和删除内存空间，扩展方便，故**空间的利用率较高**
- **任意位置插入元素和删除元素效率较高**，时间复杂度为O(1)
- 链表的**空间是从堆中分配**的



| 操作         | 数组 | 链表 |
| ------------ | ---- | ---- |
| 随机访问     | O(1) | O(N) |
| 头部插入元素 | O(N) | O(1) |
| 头部删除元素 | O(N) | O(1) |
| 尾部插入元素 | O(1) | O(1) |
| 尾部删除元素 | O(1) | O(1) |



## 栈

仅在**表尾（栈顶）进行插入和删除**操作的线性表。按照 **先进后出** 的原则存储数据。

主要操作为： push（入栈操作）、pop（出栈操作）



## 队列

仅在表的**前端（front）进行删除**操作，在表的**后端（rear）进行插入**操作。按照 **先进先出** 的原则。

#### 循环队列

- 队列判空：front = rear
- 队列判满：front = （rear+1)%MaxSize

#### 应用

1. 打印数据缓冲区
2. 操作系统处理多个进程
3. 树的层次遍历
4. 图的广度优先遍历



## 二叉树

二叉树有深度遍历和广度遍历。

- 深度遍历：前序、中序、后序
- 广度遍历：层次遍历

**1、前序遍历：根节点——左子树——右子树**

```java
public void preOrderTraverse(TreeNode root) {
	if (root != null) {
		System.out.print(root.val+ " ");
		preOrderTraverse(root.left);
		preOrderTraverse(root.right);
	}
}
```

**2、中序遍历：左子树——根节点——右子树**

```java
public void inOrderTraverse(TreeNode root) {
	if (root != null) {
		preOrderTraverse(root.left);
		System.out.print(root.val+ " ");
		preOrderTraverse(root.right);
	}
}
```

**3、后序遍历：左子树——右子树——根节点**

```java
public void postOrderTraverse(TreeNode root) {
	if (root != null) {
		preOrderTraverse(root.left);
		preOrderTraverse(root.right);
		System.out.print(root.val+ " ");
	}
}
```

**4、层次遍历：按层次进行遍历**

层次遍历需要一个**队列**即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。

```java
public void levelTraverse(TreeNode root) {
		if (root == null) {
			return;
		}
		LinkedList<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		while (!queue.isEmpty()) {
			TreeNode node = queue.poll();
			System.out.print(node.val+"  ");
			if (node.left != null) {
				queue.offer(node.left);
			}
			if (node.right != null) {
				queue.offer(node.right);
			}
		}
	}

```



## 堆

堆是一种**完全二叉树**的数组对象。

- **最小堆：**对于任意一个父结点来说，其子结点的值都大于这个父节点。
- **最大堆：**对于任意一个父结点来说，其子节点的值都小于这个父节点。



> **AVL**和**哈希表**的查找和删除的性能较好。平衡二叉树的查找，插入和删除性能都是 O(logN) ，其中查找和删除性能较好；哈希表的查找、插入和删除性能都是 O(1)



## 树与完全图

n阶树的边数为 `n-1`。

深度为N的满二叉树，节点为 `2^N-1` 个。

n阶无向完全图 C(2,n) 边数为 `n(n-1)/2`。

完全图删去 `(n-1)(n-2)/2` 条边变成树。



## 连通图

在无向图中, 若从顶点v1到顶点v2有路径, 则称顶点v1与v2是连通的。如果图中任意一对顶点都是连通的,则称此图是**连通图**。

强连通和弱连通的概念只在<u>有向图</u>中存在。

**强连通图：**在有向图中, 若对于每一对顶点v1和v2, 都存在一条从v1到v2和从v2到v1的路径,则称此图是强连通图。

**弱连通图：**将有向图的所有的有向边替换为无向边，所得到的图称为原图的基图。如果一个有向图

的基图是连通图，则有向图是弱连通图。

连通n个点的**有向图**至少需要 `n` 条边，最短边数情况为**首尾相连成环**。

连通n个点的**无向图**至少需要 `n-1` 条边，最短边数情况为**所有节点连成一条链**。



## 广义表

广义表简称表，它是**线性表的推广**。一个广义表是n（n≥0）个元素的一个序列。

- 广义表中的数据元素有相对次序；
- 广义表的长度定义为**最外层包含元素个数**；
- 广义表的深度定义为**所含括弧的重数**。其中原子的深度为0，空表的深度为1；
- 广义表可以**共享**；一个广义表可以为其他广义表共享；这种共享广义表称为<u>再入表</u>；
- 广义表可以是一个**递归**的表。一个广义表可以是自已的<u>子表</u>。这种广义表称为递归表。递归表的深度是无穷值，<u>长度是有限值</u>；
- 任何一个非空广义表GL均可分解为表头head(GL) = a1和表尾tail(GL) = ( a2,…,an) 两部分。



## 排序

[排序算法时间复杂度、空间复杂度、稳定性比较_blackboydec的博客-CSDN博客_排序算法稳定性](https://blog.csdn.net/yushiyi6453/article/details/76407640)

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | -------------- | -------------- | ---------- | -------- |
| 冒泡排序     | O(n^2)         | O(n^2)         | O(1)       | 是       |
| 选择排序     | O(n^2)         | O(n^2)         | O(1)       | 不是     |
| 直接插入排序 | O(n^2)         | O(n^2)         | O(1)       | 是       |
| 归并排序     | O(nlogn)       | O(nlogn)       | O(n)       | 是       |
| 快速排序     | O(nlogn)       | O(n^2)         | O(nlogn)   | 不是     |
| 堆排序       | O(nlogn)       | O(nlogn)       | O(1)       | 不是     |
| 希尔排序     | O(nlogn)       | O(n^2)         | O(1)       | 不是     |
| 计数排序     | O(n+k)         | O(n+k)         | O(n+k)     | 是       |
| 基数排序     | O(N*M)         | O(N*M)         | O(M)       | 是       |

- 时间复杂度
  - 冒泡、选择、直接插入排序需要两个for循环，每次只关注一个元素，O(n^2)。
  - 快速、归并、希尔、堆基于二分思想，O(nlogn）
- 稳定性 - ”快希选堆“不稳定 （快牺牲稳定性）
  - 排序算法的稳定性：排序前后相同元素的相对位置不变。

#### 插入类排序

将无序子序列中的一个或几个记录**“插入”到有序子序列**中，从而增加记录的有序子序列的长度。

包括：**直接插入排序、希尔排序**

#### 交换类排序

通过“**交换”无序序列中的记录从而得到其中关键字最小或最大的记录**，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。

包括：**冒泡排序、快速排序**

#### 选择类排序

从记录的无序子序列中**“选择”关键字最小或最大的记录**，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。

包括：**选择排序、堆排序**

#### 归并类排序

通过归并 **两个** 或 **两个以上** 的 **有序子序列** 为 **一个有序子序列**，逐步增加记录有序子序列的长度 。

包括：**归并排序**

#### 基数排序

借助 “多关键字排序” 的思想来实现“但关键字排序”的算法。

**基数排序**适合<u>并行处理</u>。

### 其他

**元素的移动次数与关键字的初始排序无关**的是：归并排序、基数排序

**元素的比较次数与初始序列无关**的是：选择排序、基数排序

**算法的时间复杂度与初始序列无关**的是：堆排序、归并排序、选择排序、基数排序



## 查找

### 二分查找

二分查找的前提有两个：**数列有序**和**无重复元素**。

其中**对区间的定义**很重要，**区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。



### 平均查找长度

- 顺序表：` (1+2+...+n)/n = (1+n)/2`
- 二叉排序树：依次将小元素放在左子树，大元素放在右子树
  - 查找成功的平均查找长度为：∑（本层高度*本层元素个数）/ 节点总数
  - 查找不成功的平均查找长度：∑（本层高度*本层补上的叶子个数）/ 补上的叶子总数

- 



## 分治算法

将一个难以直接解决的大问题，**分割成一些规模较小的相同问题**，以便各个击破，分而治之。

**分治法能解决的问题特征：**

1. 该问题的规模**缩小到一定的程度就可以容易地解决**
2. 该问题**可以分解为若干个规模较小的相同问题**，即该问题具有**最优子结构性质**。
3. 利用该问题**分解出的子问题的解可以合并为该问题的解**；（关键）
4. 该问题所分解出的**各个子问题是相互独立**的，即子问题之间不包含公共的子子问题。

> 若不满足第三条，可以考虑使用贪心法或动态规划。若不满足第四条，一般用动态规划较好。

**基本步骤：**

1. 将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
2. 若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
3. 将各个子问题的解合并为原问题的解。

**经典问题**：

**二分搜索**、大整数乘法、Strassen矩阵乘法、棋盘覆盖、**合并排序、快速排序**、线性时间选择、最接近点对问题、循环赛日程表、**汉诺塔**



## 贪心算法

在每一步选择中都采取在**当前状态下**最好或最优（即最有利）的选择，也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。

**优点：**简单，高效，省去了为了找最优解可能需要穷举操作，通常作为其它算法的辅助算法来使用。

**缺点**：

- 不能保证求得的最后解是最佳的
- 不能用来求最大或最小解问题
- 只能求满足某些约束条件的可行解的范围



## 动态规划

**基本步骤**：

1. 问题具有最优子结构性质，找出最优解性质，刻画结构特征
2. 构造最优值的递归关系表达式
3. 最优值的算法描述，计算最优值
4. 根据计算最优值时得到的信息，构造最优解



## 最小生成树解法

1. 破圈法
2. 避圈法



## 迪杰斯特拉

**基本思想**：

1. 指定一个起点D。
2. 引进两个数组S和U。S的作用是记录**已求出最短路径的顶点**(以及相应的最短路径长度)，而U则是记录**还未求出最短路径的顶点**(以及该顶点到起点D的距离)。
3. 初始时，数组S中只有起点D；数组U中是除起点D之外的顶点，并且数组U中记录各顶点到起点D的距离。如果顶点与起点D不相邻，距离为无穷大。
4. 然后，从数组U中找出**路径最短的顶点K**，并将其加入到数组S中；同时，从数组U中移除顶点K。接着，**更新数组U中的各顶点到起点D的距离**。
5. 重复第4步操作，直到遍历完所有顶点。



## 点着色问题

没有一个统一的算法，可以通过**回溯法**枚举。







## 常用算法

1. #### 括号有效性判断

   可以用正则表达式。

   也可以**定义数组作为栈** ，左括号入栈，右括号判断是否有效对应，若**对应则出栈**，最终**若栈为空则字符串合法**。

2. #### 递归翻转链表

   递归**产生除头结点外翻转完成的链表，并返回新头结点**。接下来**处理头结点和翻转完成的链表的指向以及头结点的指向**，即可完成翻转链表。

3. #### 最长不重复子串

   利用**滑动窗口**的思想，若有重复元素时，将窗口左边的元素移除出去，右边继续延伸，一直维持这样的队列，返回队列最长长度。

4. #### 目标和（494）

   可以使用**回溯**的方法遍历所有的表达式，回溯过程中维护一个计数器 count，当遇到一种表达式的结果等于目标数 target 时，将 count 的值加 1。遍历完所有的表达式之后，即可得到结果等于目标数 target 的表达式的数目。

5. 











