# 数据结构与算法



## 队列

### 循环队列

- 队列判空：front=rear
- 队列判满：front=（rear+1)%MaxSize



## 二叉树

二叉树有深度遍历和广度遍历。

- 深度遍历：前序、中序、后序
- 广度遍历：层次遍历

**1、前序遍历：根节点——左子树——右子树**

```java
public void preOrderTraverse(TreeNode root) {
	if (root != null) {
		System.out.print(root.val+ " ");
		preOrderTraverse(root.left);
		preOrderTraverse(root.right);
	}
}
```

**2、中序遍历：左子树——根节点——右子树**

```java
public void inOrderTraverse(TreeNode root) {
	if (root != null) {
		preOrderTraverse(root.left);
		System.out.print(root.val+ " ");
		preOrderTraverse(root.right);
	}
}
```

**3、后序遍历：左子树——右子树——根节点**

```java
public void postOrderTraverse(TreeNode root) {
	if (root != null) {
		preOrderTraverse(root.left);
		preOrderTraverse(root.right);
		System.out.print(root.val+ " ");
	}
}
```

**4、层次遍历：按层次进行遍历**



## 堆

堆是一种**完全二叉树**的数组对象。

- **最小堆：**对于任意一个父结点来说，其子结点的值都大于这个父节点。
- **最大堆：**对于任意一个父结点来说，其子节点的值都小于这个父节点。



> **AVL**和**哈希表**的查找和删除的性能较好。平衡二叉树的查找，插入和删除性能都是 O(logN) ，其中查找和删除性能较好；哈希表的查找、插入和删除性能都是 O(1)



## 树与完全图

n阶无向完全图 C(2,n) 边数为 `n(n-1)/2`。

n阶树的边数为 `n-1`。

完全图删去 `(n-1)(n-2)/2` 条边变成树。



## 连通图

在无向图中, 若从顶点v1到顶点v2有路径, 则称顶点v1与v2是连通的。如果图中任意一对顶点都是连通的,则称此图是**连通图**。

强连通和弱连通的概念只在<u>有向图</u>中存在。

**强连通图：**在有向图中, 若对于每一对顶点v1和v2, 都存在一条从v1到v2和从v2到v1的路径,则称此图是强连通图。

**弱连通图：**将有向图的所有的有向边替换为无向边，所得到的图称为原图的基图。如果一个有向图

的基图是连通图，则有向图是弱连通图。

连通n个点的**有向图**至少需要 `n` 条边，最短边数情况为**首尾相连成环**。

连通n个点的**无向图**至少需要 `n-1` 条边，最短边数情况为**所有节点连成一条链**。



## 广义表

广义表简称表，它是**线性表的推广**。一个广义表是n（n≥0）个元素的一个序列。

- 广义表中的数据元素有相对次序；
- 广义表的长度定义为**最外层包含元素个数**；
- 广义表的深度定义为**所含括弧的重数**。其中原子的深度为0，空表的深度为1；
- 广义表可以**共享**；一个广义表可以为其他广义表共享；这种共享广义表称为<u>再入表</u>；
- 广义表可以是一个**递归**的表。一个广义表可以是自已的<u>子表</u>。这种广义表称为递归表。递归表的深度是无穷值，<u>长度是有限值</u>；
- 任何一个非空广义表GL均可分解为表头head(GL) = a1和表尾tail(GL) = ( a2,…,an) 两部分。



## 排序

[排序算法时间复杂度、空间复杂度、稳定性比较_blackboydec的博客-CSDN博客_排序算法稳定性](https://blog.csdn.net/yushiyi6453/article/details/76407640)

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ------------ | -------------- | -------------- | ---------- | -------- |
| 冒泡排序     | O(n^2)         | O(n^2)         | O(1)       | 是       |
| 选择排序     | O(n^2)         | O(n^2)         | O(1)       | 不是     |
| 直接插入排序 | O(n^2)         | O(n^2)         | O(1)       | 是       |
| 归并排序     | O(nlogn)       | O(nlogn)       | O(n)       | 是       |
| 快速排序     | O(nlogn)       | O(n^2)         | O(nlogn)   | 不是     |
| 堆排序       | O(nlogn)       | O(nlogn)       | O(1)       | 不是     |
| 希尔排序     | O(nlogn)       | O(n^2)         | O(1)       | 不是     |
| 计数排序     | O(n+k)         | O(n+k)         | O(n+k)     | 是       |
| 基数排序     | O(N*M)         | O(N*M)         | O(M)       | 是       |

- 时间复杂度
  - 冒泡、选择、直接插入排序需要两个for循环，每次只关注一个元素，O(n^2)。
  - 快速、归并、希尔、堆基于二分思想，O(nlogn）
- 稳定性 - ”快希选堆“ （快牺牲稳定性）
  - 排序算法的稳定性：排序前后相同元素的相对位置不变。

**希尔排序**是<u>插入类排序法</u>。

**基数排序**适合<u>并行处理</u>。

**元素的移动次数与关键字的初始排序无关**的是：归并排序、基数排序

**元素的比较次数与初始序列无关**的是：选择排序、基数排序

**算法的时间复杂度与初始序列无关**的是：堆排序、归并排序、选择排序、基数排序

堆排序，初始堆为？



## 查找

### 二分查找

二分查找的前提有两个：**数列有序**和**无重复元素**。

其中**对区间的定义**很重要，**区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。



### 平均查找长度

- 顺序表：` (1+2+...+n)/n = (1+n)/2`



## 分治算法

将一个难以直接解决的大问题，**分割成一些规模较小的相同问题**，以便各个击破，分而治之。

**分治法能解决的问题特征：**

1. 该问题的规模**缩小到一定的程度就可以容易地解决**
2. 该问题**可以分解为若干个规模较小的相同问题**，即该问题具有**最优子结构性质**。
3. 利用该问题**分解出的子问题的解可以合并为该问题的解**；（关键）
4. 该问题所分解出的**各个子问题是相互独立**的，即子问题之间不包含公共的子子问题。

> 若不满足第三条，可以考虑使用贪心法或动态规划。若不满足第四条，一般用动态规划较好。

**基本步骤：**

1. 将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
2. 若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
3. 将各个子问题的解合并为原问题的解。

**经典问题**：

**二分搜索**、大整数乘法、Strassen矩阵乘法、棋盘覆盖、**合并排序、快速排序**、线性时间选择、最接近点对问题、循环赛日程表、**汉诺塔**



## 动态规划

**基本步骤**：

1. 问题具有最优子结构性质，找出最优解性质，刻画结构特征
2. 构造最优值的递归关系表达式
3. 最优值的算法描述，计算最优值
4. 根据计算最优值时得到的信息，构造最优解



## 最小生成树解法

1. 破圈法
2. 避圈法



## 迪杰斯特拉

**基本思想**：

1. 指定一个起点D。
2. 引进两个数组S和U。S的作用是记录**已求出最短路径的顶点**(以及相应的最短路径长度)，而U则是记录**还未求出最短路径的顶点**(以及该顶点到起点D的距离)。
3. 初始时，数组S中只有起点D；数组U中是除起点D之外的顶点，并且数组U中记录各顶点到起点D的距离。如果顶点与起点D不相邻，距离为无穷大。
4. 然后，从数组U中找出**路径最短的顶点K**，并将其加入到数组S中；同时，从数组U中移除顶点K。接着，**更新数组U中的各顶点到起点D的距离**。
5. 重复第4步操作，直到遍历完所有顶点。



## 点着色问题

没有一个统一的算法，可以通过**回溯法**枚举。















