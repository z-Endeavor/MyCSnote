# JavaScript



## 数据类型

JS分为 **基本数据类型** 和 **引用数据类型** 。

### 基本类型

基本数据类型有 **字符串（String）、数字（Number）、布尔（Boolean）、空（Boolean）、未定义（Undefined）、Symbol** 。

- `String`：以 `''` 或 `""` 包裹起来的文本。若包含引号， 可以使用 `\` 反斜杠转义字符串中的引号。
- `Number`：不区分整数和小数（浮点数）。

> NaN 是特殊值，表示不是数字，但是属于 Number 类型，不等于任何值。

- `Boolean`：只有 true 和 false 两个值。
- `Null`：只有一个值，表示不存在任何值，用来定义空对象指针。

> 使用 `typeof` 查看 Null类型，结果为 Object ，说明 Null 其实属于 Object（对象） 的一个特殊值。

- `Undefined`：只有一个值，表示未定义。当声明变量后未赋值，默认值就是Undefined。
- `Symbol`：ES6引入的新的数据类型，表示独一无二的值，需要用Symbol()函数来生成。

```javascript
var str = "123";
var sym1 = Symbol(str);
var sym2 = Symbol(str);
console.log(sym1);          // 输出 Symbol(123)
console.log(sym2);          // 输出 Symbol(123)
console.log(sym1 == sym2);  // 输出 false ：虽然 sym1 与 sym2 看起来是相同的，但实际上它们并不一样，根据 Symbol 类型的特点，sym1 和 sym2 都是独一无二的
```

基本数据类型是**按值访问**的，也就是说**可以操作保存在变量中实际的值**。

### 引用类型

引用数据类型有 **对象（Object）、数组（Array）、函数（Function）等**。

- `Object`：是一组由键、值组成的无序集合，定义使用 `{}` 。
- `Array`：是一组按顺序排列的数据集合，可以包含任意类型的数据，定义使用 `[]` 或者 `new Array()`，每个元素用逗号分隔。
- `Function`：是一段特定功能的代码块。

#### 区别

1. **值的可变性：**
   - 基本类型的值是**不可变**的，原始值无法通过方法改变，也不能添加属性和方法。
   - 引用类型的值是可变的，可以添加删除属性和方法，可以**动态改变**。
2. **值比较：**
   - 基本类型只有**值相等**的时候才相等。
   - 引用类型的比较是**引用的比较**。
3. **内存存放：**
   - 基本类型的存放在**栈区**，包括<u>变量的标识符和变量的值</u>。
   - 引用类型同时保存在**栈内存和堆内存**中，栈区存放<u>变量标识符</u>和<u>该对象在堆内存的地址</u>。



## == 和 === 的区别

== 比较时，**不同类型的数据会转换成一致后再做比较**。

=== 比较时，如果类型不一致就直接返回 `false` ，**类型相同才会比较**。



## Set

Set 与数组类似， Set 集合中的**元素不重复**。

- 查找元素`set.has()`： 在数组中使用 indexOf() 或 includes() 检查元素是否存在比较慢。
- 删除元素`set.delete()`： 在 Set 中，可以通过值删除元素。即在数组中，基于索引的splice() 功能。
- 插入元素`set.add()`： 在 Set 中添加元素比在数组中通过 push()、 unshift() 或其他同类操作要快。
- 去重： Set 对象仅能存储不同的值。



## Promise

**`Promise`** 对象用于表示一个**异步操作**的最终完成（或失败）及其结果值。

一个 `Promise` 必然处于以下几种状态之一：

- *待定（pending）*：初始状态，既没有被兑现，也没有被拒绝。
- *已兑现（fulfilled）*：意味着操作成功完成。
- *已拒绝（rejected）*：意味着操作失败。

### 链式调用

`Promise.prototype.then()`、`Promise.prototype.catch()` 和 `Promise.prototype.finally()` 这些方法返回的是promise，可以将进一步的操作与一个变为已敲定状态的 promise 关联起来链式调用。

```javascript
const p = new Promise((res, rej) => {
  res(117);
  setTimeout(() =>{
    throw new Error('None');
  }, 0);
});
p.then((res) =>{
  console.log(res);
}).catch((err) =>{
  console.log(err)
})

// 117 报错
```



## 可变参数

```javascript
function func(arg, ...obj) {
  console.log(arguments.length, obj.length, func.length);
};

func(1,2,3);

// 3 2 1
```



## 事件流

事件流描述的是从页面中接收事件的顺序，即事件在目标元素和祖先元素间的触发顺序。DOM2级事件流包括下面几个阶段：

1. 事件捕获阶段：事件**从最顶层向下传播**，从window一直传递到目标元素。
2. 处于目标阶段：到达目标元素。若指定不冒泡，则中止。
3. 事件冒泡阶段：事件**从下往上传播**，事件由第一个被触发的元素接收，逐级向上传递直到最顶层元素。

`addEventListener` ：是DOM2级事件的指定事件处理程序的操作，要处理3个参数（事件名、事件处理函数、布尔值）。若布尔值参数为 `true` ，则在捕获阶段调用事件处理程序；如果为 `false` ，则在冒泡阶段调用事件处理程序。

> 默认设置为**事件冒泡阶段**。IE 只支持事件冒泡。

### 事件委托

利用DOM的**冒泡事件流**，注册最少的监听器，<u>实现对DOM节点的所有子元素进行事件群控</u>。

一般来说会把**一个或者一组元素的事件委托到它的父层或者更外层元素**上，当事件响应到需要绑定的元素上，会**通过事件冒泡机制触发外层元素的绑定事件**，然后在外层事件上执行函数。

利用 事件委托 可以减少与DOM节点进行交互以及浏览器重绘和重排的次数，提高性能。

### target 和 currentTarget

- `target` ：触发事件的元素
- `currentTarget` ：事件绑定的元素

事件不支持冒泡的时候，两者指的是同一个元素。

事件支持冒泡的时候，比如父元素和子元素都绑定click事件，当点击子元素时，父元素的事件也会触发，此时父元素事件的currentTarget指向父元素，target指向子元素。



## 跨域





## 正则表达式

正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，**正则表达式也是对象**。

这些模式被用于 `RegExp` 的 `exec` 和 `test` 方法，以及 `String` 的 `match`、`matchAll`、`replace`、`search` 和 `split` 方法。

### 字符

| 表达式 | 描述                                             |
| ------ | ------------------------------------------------ |
| [abc]  | 字符集。匹配集合中任一字符。                     |
| [^abc] | 否定字符集。匹配任何不在集合中的字符。           |
| [a-z]  | 字符范围。匹配指定范围内的任意字符。             |
| .      | 匹配除换行符以外的任何单个字符                   |
| \      | 转义字符                                         |
| \w     | 匹配任意字母数字，包括下划线（`[A-Za-z0-9_]`)    |
| \W     | 匹配任意非字母数字，包括下划线（`[^A-Za-z0-9_]`) |
| \d     | 数字。匹配任何数字。                             |
| \D     | 非数字。匹配任何非数字字符。                     |
| \s     | 空白。匹配任何空白字符，包括空格、制表符等。     |
| \S     | 非空白。匹配任何非空白字符。                     |

### 锚点/边界

| 表达式 | 描述                                       |
| ------ | ------------------------------------------ |
| ^      | 匹配字符串或行开头。                       |
| $      | 匹配字符串或行结尾。                       |
| \b     | 匹配单词边界。`now\b => rightnow`          |
| \B     | 匹配非单词边界。 `right\B => justrightnow` |

### 数量表示

| 表达式 | 描述                               |
| ------ | ---------------------------------- |
| ？     | 匹配前面的表达式0或1个。即可选项。 |
| +      | 匹配前面的表达式至少1个。          |
| *      | 匹配前面的表达式0个或多个。        |
| \|     | 或运算符。                         |
| {m}    | 匹配前面的表达式m个。              |
| {m,}   | 匹配前面的表达式最少m个。          |
| {m,n}  | 匹配前面的表达式m-n个。            |

### 特殊标志

| 表达式 | 描述                       |
| ------ | -------------------------- |
| /.../i | 忽略大小写                 |
| /.../g | 全局匹配                   |
| /.../m | 多行修饰符，用于多行匹配。 |



# HTML







# CSS



## 盒子模型

盒子模型本质上就是一个盒子，封装周围的HTML元素，它包括四个部分：

-  `content` ：实际内容
- `padding` ：内边距，清除内容周围的区域，是透明的，取值不能为负，受盒子 `background`属性影响。
- `border` ：边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成。
-  `margin` ：外边距，在元素外创建额外的空白，通常指不能放其他元素的区域。

> `width / height `属性只是内容宽度和高度，不包含其他的。
>
> 盒子总宽度 = width + padding + border + margin
>
> 盒子总高度 = height + padding + border + margin



## BFC 块格式化上下文

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

### 创建BFC

1. 浮动元素：float属性不为`none`（指定float为left或者right都可以）
2. 绝对定位元素：position为`absolute`或`fixed`
3. display: `inline-block`、`table-cell`、`table-caption`、`flex`、`inline-flex`
4. overflow不为`visible`

### BFC特点

1. 在BFC中，盒子从顶部开始垂直地一个接一个排列
2. 盒子垂直方向的距离由margin决定。同一个BFC的两个相邻盒子margin会重叠。
3. BFC中，margin-left会触碰到border-left（对于从左至右的方式，反之）
4. BFC区域不会与浮动的盒子产生交集，而是紧贴边缘浮动
5. 计算BFC高度时，自然会检测浮动的盒子高度

### BFC用途

1. 清除内部浮动，父元素设置为BFC可以清除子元素的浮动（最常用overflow:hidden，IE6需加上*zoom:1）：计算BFC高度时会检测浮动子盒子高度
2. 解决外边距合并问题
3. 右侧盒子自适应：BFC区域不会与浮动盒子产生交集，而是紧贴浮动边缘



## 定位





## 伪类

- :hover选择器：当鼠标**悬停在所指定的元素**上时所使用的样式；
- :active选择器：当所指定的元素处于**激活状态**（鼠标在元素上按下还没有松开）时所使用的样式；
- :focus选择器：当元素获得光标焦点时使用的样式，主要用在**文本框输入文字**时使用；



怎么实现水平居中、垂直居中









# 浏览器



## 提高cookie安全性的方法

1. 对保存到cookie里面的敏感信息必须加密
2. 设置HttpOnly为true，无法通过脚本访问或操作，防止关键性的数据被恶意获取。
3. 设置Secure为true，强制开启HTTPS连接。
4. 给Cookie设置有效期
5. 给Cookies加个时间戳和IP戳，实际就是让Cookies在同个IP下多少时间内失效。



## 浏览器本地存储技术

### cookie和session

cookie和session都可用来存储用户信息。

1. cookie 数据存放在客户端的浏览器上，session 数据放在服务器上。
2. cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行cookie欺骗。考虑到安全应当使用 session。
3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie。
4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。

### cookie、localStorage和sessionStorage 

都是保存在浏览器端，并且是同源的。

#### 生命周期

- cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效
- localStorage：除非被手动清除，否则将会永久保存。
- sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。

#### 存放数据大小

- cookie：4KB左右
- localStorage和sessionStorage：可以保存5MB的信息。

#### http请求

- cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
- localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

#### 易用性

- cookie：需要程序员自己封装，源生的Cookie接口不友好
- localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持

#### 应用场景

从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。

storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了。

localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。



## 浏览器输入URL发生了什么

1. **URL解析**

   - 用户输入URL，浏览器会根据用户输入的信息判断是**搜索还是网址**，如果是<u>搜索内容+默认搜索引擎合成新的URL</u>；如果用户输入的内容符合URL规则，浏览器就会<u>根据URL协议，在这段内容加上协议合成合法的URL</u>。

2. **DNS查询**

   - 输入URL后，首先需要找到URL域名的服务器IP，因此浏览器**先去查看缓存中是否有记录**（<u>浏览器缓存—系统缓存—路由器缓存</u>）。
   - 若缓存中没有则**查找系统的hosts文件**是否有记录。
   - 若没有则**向本地配置的首选DNS服务器发起域名解析请求**。
   - 最终得到服务器的IP地址。

3. **TCP连接**

   - 在确定目标服务器服务器的IP地址后，则经历**三次握手**建立TCP连接。
   - 发送端首先**发送一个带SYN**（synchronize）标志的数据包给接收方。
   - 接收方收到后，**回传一个带有SYN / ACK** (acknowledegment)标志的数据包以示传达确认信息。
   - 最后发送方再**回传一个带ACK**标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP会再次发送相同的数据包。 TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。

4. **HTTP请求**

   - TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了，**发送HTTP请求报文**到目标服务器。
   - 服务器接受到请求，就解析请求头，如果头部有缓存相关信息如f-none-match与f-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。

5. **接受响应**

   - 服务器解析请求作出响应，返回相应的HTML给浏览器。
   - 因为HTML是一个树形结构，浏览器根据这个HTML来构建DOM树。
   - 在DOM树构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码（JS阻塞)

6. **渲染页面**

   - 渲染进程解析 HTML，构建DOM树。
   - 渲染引擎解析CSS 样式表，转化为浏览器可以理解的styleSheets，生成CCSOM（CSS规则树）。
   - 合成DOM树和CSS规则树，生成render树（渲染树）。
   - 布局render树（Layout / reflow），并计算元素的布局信息（尺寸、位置）。

   > reflow 回流： 重新渲染的过程。

   - 绘制render树（paint / repaint），绘制页面像素信息。

   - 浏览器进程将各层信息发送给GPU，GPU合成，根据指令生成页面，并显示到显示器上。






# Vue



EventBus怎么通信？发布订阅模式？





