# JavaScript



## 数据类型



## Set

Set 与数组类似， Set 集合中的**元素不重复**。

- 查找元素`set.has()`： 在数组中使用 indexOf() 或 includes() 检查元素是否存在比较慢。
- 删除元素`set.delete()`： 在 Set 中，可以通过值删除元素。即在数组中，基于索引的splice() 功能。
- 插入元素`set.add()`： 在 Set 中添加元素比在数组中通过 push()、 unshift() 或其他同类操作要快。
- 去重： Set 对象仅能存储不同的值。



## Promise

**`Promise`** 对象用于表示一个**异步操作**的最终完成（或失败）及其结果值。

一个 `Promise` 必然处于以下几种状态之一：

- *待定（pending）*：初始状态，既没有被兑现，也没有被拒绝。
- *已兑现（fulfilled）*：意味着操作成功完成。
- *已拒绝（rejected）*：意味着操作失败。

### 链式调用

`Promise.prototype.then()`、`Promise.prototype.catch()` 和 `Promise.prototype.finally()` 这些方法返回的是promise，可以将进一步的操作与一个变为已敲定状态的 promise 关联起来链式调用。

```javascript
const p = new Promise((res, rej) => {
  res(117);
  setTimeout(() =>{
    throw new Error('None');
  }, 0);
});
p.then((res) =>{
  console.log(res);
}).catch((err) =>{
  console.log(err)
})

// 117 报错
```



## 可变参数

```javascript
function func(arg, ...obj) {
  console.log(arguments.length, obj.length, func.length);
};

func(1,2,3);

// 3 2 1
```





# HTML







# CSS



## 盒子模型

盒子模型本质上就是一个盒子，封装周围的HTML元素，它包括四个部分：

-  `content` ：实际内容
- `padding` ：内边距，清除内容周围的区域，是透明的，取值不能为负，受盒子 `background`属性影响。
- `border` ：边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成。
-  `margin` ：外边距，在元素外创建额外的空白，通常指不能放其他元素的区域。

> `width / height `属性只是内容宽度和高度，不包含其他的。
>
> 盒子总宽度 = width + padding + border + margin
>
> 盒子总高度 = height + padding + border + margin



## BFC 块格式化上下文

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

### 创建BFC

1. 浮动元素：float属性不为`none`（指定float为left或者right都可以）
2. 绝对定位元素：position为`absolute`或`fixed`
3. display: `inline-block`、`table-cell`、`table-caption`、`flex`、`inline-flex`
4. overflow不为`visible`

### BFC特点

1. 在BFC中，盒子从顶部开始垂直地一个接一个排列
2. 盒子垂直方向的距离由margin决定。同一个BFC的两个相邻盒子margin会重叠。
3. BFC中，margin-left会触碰到border-left（对于从左至右的方式，反之）
4. BFC区域不会与浮动的盒子产生交集，而是紧贴边缘浮动
5. 计算BFC高度时，自然会检测浮动的盒子高度

### BFC用途

1. 清除内部浮动，父元素设置为BFC可以清除子元素的浮动（最常用overflow:hidden，IE6需加上*zoom:1）：计算BFC高度时会检测浮动子盒子高度
2. 解决外边距合并问题
3. 右侧盒子自适应：BFC区域不会与浮动盒子产生交集，而是紧贴浮动边缘



## 伪类

- :hover选择器：当鼠标**悬停在所指定的元素**上时所使用的样式；
- :active选择器：当所指定的元素处于**激活状态**（鼠标在元素上按下还没有松开）时所使用的样式；
- :focus选择器：当元素获得光标焦点时使用的样式，主要用在**文本框输入文字**时使用；





# 浏览器



## 提高cookie安全性的方法

1. 对保存到cookie里面的敏感信息必须加密
2. 设置HttpOnly为true，无法通过脚本访问或操作，防止关键性的数据被恶意获取。
3. 设置Secure为true，强制开启HTTPS连接。
4. 给Cookie设置有效期
5. 给Cookies加个时间戳和IP戳，实际就是让Cookies在同个IP下多少时间内失效。



## 浏览器本地存储技术

### cookie和session

cookie和session都可用来存储用户信息。

1. cookie 数据存放在客户端的浏览器上，session 数据放在服务器上。
2. cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行cookie欺骗。考虑到安全应当使用 session。
3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie。
4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。

### cookie、localStorage和sessionStorage 

都是保存在浏览器端，并且是同源的。

#### 生命周期

- cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效
- localStorage：除非被手动清除，否则将会永久保存。
- sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。

#### 存放数据大小

- cookie：4KB左右
- localStorage和sessionStorage：可以保存5MB的信息。

#### http请求

- cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
- localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

#### 易用性

- cookie：需要程序员自己封装，源生的Cookie接口不友好
- localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持

#### 应用场景

从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。

storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了。

localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。



